# GC Algorithm



## Category

* 标记阶段: 判断对象的死活

    1. 引用记数算法:  Reference Counting 
        
            概念：
            对于每一个对象，保存一个整形(int)的引用计数器属性，用于记录对象被引用的情况。对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就+1；当引用失效时，引用计数器就-1。只要对象A的引用计数器的值为0, 即表示对象A不可能再被使用，可进行回收♻️
            
            优点：
                
                实现简单，垃圾对象便于辨识
                判定效率高，回收没有延迟性 （不需要等到oom了才GC, 只要引用计数器 == 0就可以回收)
            
            缺点: 
                
                需要维护这个引用计数器的属性 (space/time)
                ！！！致命问题：无法处理循环引用的情况 
            
                ![loopReference](imagePool/loopReference.png)
    
    
    2. 可达性分析算法
    
            概念：
                
                以根对象的集合(GC Roots)为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。b非直接或间接可达的对象就被判断为垃圾。
            
            GC Roots:
            
                虚拟机栈中的引用
                本地方法栈中的引用
                方法区中类静态属性的引用
                方法区中常量(String Table)的引用
                等等
                
                (小技巧: 如果一个变量保存了堆内存里面的对象，但自己又不存放在堆内存里面，它就是一个Root)
            
            优点: 
                
                实现简单
                解决了loop reference 的问题
            
            注意点: 
                
                GC标记的时候需要STW (stop the world, 停止所有用户线程的调用)
 

* 清除阶段的算法: 

    1. 标记-清除 (Mark - Sweep) 算法
    
            概念:
                
                当堆中的有效内存空间(available memory) 被耗尽的时候，就会停止整个程序(Stop-the-world)，然后进行两项工作，第一项是标记，第二项是清除。清除并不是真的置空所有数据，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就在垃圾处覆盖存放即可。
                
                标记: Collector 从GC Roots开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象
                清除: Collector 对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收
            
            缺点:
            
                效率不高 - 在标记和清除阶段进行两次全遍历
                在进行GC的时候，需要停止整个应用程序，导致用户体验差
                这种方式清理出来的空闲内存是不连续的，产生内存碎片。需要维护一个空闲列表来记录
                
        2. 复制 (Copying) 算法        
        
                概念: 
                
                    将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收
                
                优点:
                    
                    执行效率最高, 不需要标记和清除过程
                    复制过去之后保证了内存空间的连续性，不会出现内存碎片的问题
                    
                缺点：
                
                    需要两倍大的内存空间
                    需要维护region之间对象引用关系，不管是内存占用或者时间开销都不小
                    只适合使用在垃圾多的场合 (垃圾朝生夕死), 如果系统中的垃圾很少，存活对象很多时，复制算法就很浪费不理想；极限情况 -- 如果完全没有垃圾，相当于完全复制了一份存活对象； 所以适合使用在Young Gen
                    
                使用场合: 
                    
                    Young Gen
                
        3. 标记-压缩/整理 (Mark - compact) 算法
            
                概念：
                
                    先标记，然后将所有存活的对象压缩到内存的一端，按顺序排放(压缩/整理), 最后清理边界外的所有空间
                
                优点:
                
                    消除了标记 - 清除算法中内存碎片的问题，JVM也不需要维护空闲列表，只需要一个内存的起始地址即可
                    消除了复制算法中，开辟两块内存空间的成本
                
                缺点： 
                
                    效率低于复制算法
                    对象移动的过程当中，如果对象被其他对象引用，则还需要调整引用的地址
                    
                使用场合: 
                
                    Tenured Gen
                    
                    
